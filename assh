#!/usr/bin/expect -f

set PROG_DIR    "$env(HOME)/auto_ssh/"
set FILE_HOSTS  "${PROG_DIR}known_hosts"
set FILE_PASS   "${PROG_DIR}psw.enc"
set CIPHER_ALG  "aes-256-cbc"
set MASTER_PASS ""

# ------------------------------------------------------------------------------
proc get_server_info {category nick1 nick2 nick3} {
    global FILE_HOSTS

    set host ""
    set pass_key ""

    set fp [open $FILE_HOSTS r]
    while {-1 != [gets $fp line]} {
        regsub -all {[ \t]} $line {} line
        if [
           regexp -nocase "${category},${nick1},${nick2},${nick3},\(\[\^,\]\+\),\(\[\^,\]\+\),\(\.\+\)\$" $line match user host pass_key
           ] then {
           break
        }
    }
    close $fp
    return [list $user $host $pass_key]
}
# ------------------------------------------------------------------------------
proc read_pass_file {master_p} {
    global CIPHER_ALG
    global FILE_PASS

    set exit_code [catch {exec openssl $CIPHER_ALG -d -pass pass:$master_p -in $FILE_PASS} pass_list]

    return [list $exit_code $pass_list]
}
# ------------------------------------------------------------------------------
proc get_pass_val {pass_key} {
    global MASTER_PASS
    set pass_val ""

    set result [read_pass_file $MASTER_PASS]
    set exit_code [lindex $result 0]
    set pass_list [split [lindex $result 1] "\n" ]

    if {$exit_code == 0 } {
        foreach line $pass_list {
            if [
               regexp -nocase "\^\[ \\t\]\*${pass_key}\[ \\t]+\(\[\^ \\t\]\+\)" $line match pass_val
               ] then {
               puts " found     = \[$pass_val\]"
               break
            }
        }
    }
    return $pass_val
}

# ------------------------------------------------------------------------------
proc ssh {user host pass} {
    # -o "StrictHostKeyChecking no"  to avoid typing 'yes' on "Are you sure you want to continue connecting (yes/no)?"
    spawn ssh -o "StrictHostKeyChecking no" ${user}@$host
        expect "assword:*"
        send -- "$pass\r"
        send -- "\r"
        interact
}

# ------------------------------------------------------------------------------
proc init_master_p {accept} {
    global FILE_PASS
    global MASTER_PASS

    stty -echo
    send_user -- "give master password:"
    expect_user -re "(.*)\n"
    send_user "\n"
    stty echo

    #set input $expect_out(0,string)
    #if {$input eq ""} { # timeout and nothing entered
    #   exit
    #}

    set master_p $expect_out(1,string)

    if {$accept == 0} {
        set result [read_pass_file $master_p]
        set exit_code [lindex $result 0]
        if {$exit_code == 0} {
            set accept 1
        }
    }

    if {$accept == 1} {
        set MASTER_PASS $master_p
        return 0
    }
    puts "Master password doesn't match with $FILE_PASS"
    return 1
}
# ------------------------------------------------------------------------------
proc print_help {} {
    global FILE_HOSTS
    global FILE_PASS
    set prog   [info script]
    puts " $prog \[-d]\[-c file] \[category \[nick1] \[nick2] \[nick3]]\n"
    puts "\t- \[-d] dump the password file $FILE_PASS"
    puts "\t- \[-c file] create a password file $FILE_PASS"
    puts "\t- \[category \[nick1] \[nick2] \[nick3]] ssh into the server matched in $FILE_HOSTS"
}
# ------------------------------------------------------------------------------
proc dump_pass_file {} {
    global argv
    global MASTER_PASS

    if {[init_master_p 1] == 0 } {

        set result [read_pass_file $MASTER_PASS]
        set exit_code [lindex $result 0]

        if {$exit_code == 0 } {
            set file   [lindex $argv 1]
            if {$file eq "" } {
                puts "output file not specified"
                return
            }
            if [catch {set fp [open $file w] } errmsg] {
                puts "unable to create file $file"
                return
            }

            puts $fp [lindex $result 1]
            close $fp
        }
    }
}
# ------------------------------------------------------------------------------
proc create_pass_file {} {
    global argv
    global MASTER_PASS
    global FILE_PASS
    global CIPHER_ALG

    set file   [lindex $argv 1]
    if {[file exist $file] != 1} {
        puts "input file $file does not exist"
        return
    }
    set exit_code [catch {exec cp $FILE_PASS ${FILE_PASS}.bk } errmsg]
    if {$exit_code == 0 } {
       puts "created backup: \[${FILE_PASS}.bk] for old file"
    }

    if {[init_master_p 1] == 0 } {
        exec openssl $CIPHER_ALG -pass pass:$MASTER_PASS -in $file -out $FILE_PASS
    }
}
# ------------------------------------------------------------------------------
proc init {} {
    global MASTER_PASS
    global FILE_HOSTS
    global FILE_PASS

    if {[file exist $FILE_HOSTS] != 1} {
        puts "missing file $FILE_HOSTS "
        return 1
    }
    if {[file exist $FILE_PASS] != 1} {
        puts "missing file $FILE_PASS "
        return 1
    }
    if {[init_master_p 0] != 0 } {
        return 1
    }
    return 0
}
# ------------------------------------------------------------------------------
proc check_args {} {
    global argv
    set arg1   [lindex $argv 0]

    if {($arg1 eq "" || $arg1 eq "-h")} {
       print_help
       return 1
    }
    if {$arg1 eq "-d" } {
       dump_pass_file
       return 1
    }
    if {$arg1 eq "-c" } {
       create_pass_file
       return 1
    }
    return 0
}
# ------------------------------------------------------------------------------
proc main {} {
    global FILE_HOSTS
    global FILE_PASS
    global argv

    set category   [lindex $argv 0]
    set nick1      [lindex $argv 1]
    set nick2      [lindex $argv 2]
    set nick3      [lindex $argv 3]

    if { ([check_args] == 0 && [init] == 0) } {
        set server_info [get_server_info $category $nick1 $nick2 $nick3]
        set user     [lindex $server_info 0]
        set host     [lindex $server_info 1]
        set pass_key [lindex $server_info 2]

        if {$pass_key eq "" } {
            puts "no match found for \[$category\] \[$nick1\] \[$nick2\] \[$nick3\] in $FILE_HOSTS"
        } else {
            set pass [get_pass_val $pass_key]
            if {$pass eq "" } {
                puts "no key found for \[${pass_key}\] in ${FILE_PASS}"
            } else {
                ssh $user $host $pass
            }
        }
    }
}

# ------------------------------------------------------------------------------
main

