#!/usr/bin/expect -f

package require cmdline

set OPTIONS     ()

# read config from outside
source config

set MASTER_PASS ""

# ------------------------------------------------------------------------------
proc get_server_info {category nick1 nick2 nick3} {
    global FILE_HOSTS

    set host ""
    set user ""
    set pass_key ""

    set fp [open $FILE_HOSTS r]
    while {-1 != [gets $fp line]} {
        regsub -all {[ \t]} $line {} line
        if [
           regexp -nocase "${category},${nick1},${nick2},${nick3},\(\[\^,\]\+\),\(\[\^,\]\+\),\(\.\+\)\$" $line match user host pass_key
           ] then {
           break
        }
    }
    close $fp
    return [list $user $host $pass_key]
}
# ------------------------------------------------------------------------------
proc read_pass_file {masterp} {
    global CIPHER_ALG
    global FILE_PASS

    set exit_code [catch {exec openssl $CIPHER_ALG -d -pass pass:$masterp -in $FILE_PASS} pass_list]

    return [list $exit_code $pass_list]
}
# ------------------------------------------------------------------------------
proc get_masterp_from_env {} {
    global env
    global CIPHER_ALG
    global MASTER_PASS
    global CONFIG_MP_KEY
    global CONFIG_MP

    catch {set env_value "$env($CONFIG_MP)"} err
    set exit_code [catch {exec echo $env_value | openssl $CIPHER_ALG -d -a -pass pass:$CONFIG_MP_KEY} decrypt ]
    if {$exit_code != 0 } {
        puts "Unable to read master-password from env-var"
        set decrypt [prompt_for_masterp]
    }
    if {$decrypt ne "" } {
        set MASTER_PASS $decrypt
    }
}
# ------------------------------------------------------------------------------
proc set_masterp_for_env {} {
    global CIPHER_ALG
    global CONFIG_MP_KEY

    set masterp [prompt_for_masterp]
    set exit_code [catch {exec echo $masterp | openssl $CIPHER_ALG -a -pass pass:$CONFIG_MP_KEY} encrypt ]
    if {$exit_code == 0 } {
        set $encrypt ""
    }
    return $encrypt
}
# ------------------------------------------------------------------------------
proc get_pass_val {pass_key} {
    global MASTER_PASS
    set pass_val ""

    set result [read_pass_file $MASTER_PASS]
    set exit_code [lindex $result 0]
    set pass_list [split [lindex $result 1] "\n" ]

    if {$exit_code == 0 } {
        foreach line $pass_list {
            if [
               regexp -nocase "\^\[ \\t\]\*${pass_key}\[ \\t]\*,\(\.\+\)" $line match pass_val
               ] then {
               break
            }
        }
    }
    return $pass_val
}

# ------------------------------------------------------------------------------
proc ssh {user host pass} {
    # -o "StrictHostKeyChecking no"  to avoid typing 'yes' on "Are you sure you want to continue connecting (yes/no)?"
    spawn ssh -o "StrictHostKeyChecking no" ${user}@$host
        expect "assword:*"
        send -- "$pass\r"
        send -- "\r"
        interact
}

# ------------------------------------------------------------------------------
proc prompt_for_masterp {} {

    stty -echo
    send_user -- "give master password:"
    expect_user -re "(.*)\n"
    send_user "\n"
    stty echo

    #set input $expect_out(0,string)
    #if {$input eq ""} { # timeout and nothing entered
    #   exit
    #}

    return $expect_out(1,string)
}
# ------------------------------------------------------------------------------
proc init_masterp {accept} {
    global FILE_PASS
    global MASTER_PASS

    if { $MASTER_PASS eq "" } {
        set masterp [prompt_for_masterp]

        if {$accept == 0} {
            set result [read_pass_file $masterp]
            set exit_code [lindex $result 0]
            if {$exit_code == 0} {
                set accept 1
            }
        }

        if {$accept == 1} {
            set MASTER_PASS $masterp
            return 0
        }
        puts "Master password doesn't match with $FILE_PASS"
        return 1
    }
    return 0
}
# ------------------------------------------------------------------------------
proc dump_pass_file {filename} {
    global MASTER_PASS

    set err [init_masterp 1]
    if {$err == 0} {

        set result [read_pass_file $MASTER_PASS]
        set exit_code [lindex $result 0]

        if {$exit_code == 0 } {
            if [catch {set fp [open $filename w] } errmsg] {
                puts "unable to create file $filename"
                return 1
            }

            puts $fp [lindex $result 1]
            close $fp
        }
    }
    return $err
}
# ------------------------------------------------------------------------------
proc create_pass_file {filename} {
    global MASTER_PASS
    global FILE_PASS
    global CIPHER_ALG

    if {[file exist $filename] != 1} {
        puts "file $filename does not exist"
        return
    }
    set exit_code [catch {exec cp $FILE_PASS ${FILE_PASS}.bk } errmsg]
    if {$exit_code == 0 } {
       puts "created backup: \[${FILE_PASS}.bk] for old file"
    }

    if {[init_masterp 1] == 0 } {
        exec openssl $CIPHER_ALG -pass pass:$MASTER_PASS -in $filename -out $FILE_PASS
    }
}
# ------------------------------------------------------------------------------
proc init {} {
    global MASTER_PASS
    global FILE_HOSTS
    global FILE_PASS

    if {[file exist $FILE_HOSTS] != 1} {
        puts "missing file $FILE_HOSTS "
        return 1
    }
    if {[file exist $FILE_PASS] != 1} {
        puts "missing file $FILE_PASS "
        return 1
    }
    if {[init_masterp 0] != 0 } {
        return 1
    }
    return 0
}
# ------------------------------------------------------------------------------
proc check_args {} {
    global FILE_HOSTS
    global MASTER_PASS
   # global FILE_PASS

    set usage "\[-c file]\[-d file]\[-mp] \[category \[nick1] \[nick2] \[nick3]]\n"
    append usage "---- prog to ssh into a server matched in $FILE_HOSTS\n"

    set parameters {
        {c.arg  ""   "create a password-file"}
        {d.arg  ""   "dump the password-file into the specified file"}
        {mp     ""   "use config master-password"}
        {cmp    ""   "create master-password"}
    }
    if {[catch {array set options [cmdline::getoptions ::argv $parameters $usage]} errmsg]} {
         puts $errmsg
         return 1
    }

    if {$options(cmp) != 0} {     # propmpt for a string and return it encrypted
        set masterp [set_masterp_for_env ]
        puts $masterp
        return 1
    } else {
        if {$options(mp) != 0} {  # init master-p from env-var
            get_masterp_from_env
        }

        if {$options(d) ne ""} {  # dump
            set finish [dump_pass_file $options(d)]
            return 1
        } elseif { $options(c) ne ""} { # create
            set finish [create_pass_file $options(c)]
            return 1
        }
    }
    return 0
}

# ------------------------------------------------------------------------------
proc main {} {
    global FILE_HOSTS
    global FILE_PASS
    global argv

    if { ([check_args] == 0 && [init] == 0) } {

        set category   [lindex $argv 0]
        set nick1      [lindex $argv 1]
        set nick2      [lindex $argv 2]
        set nick3      [lindex $argv 3]

        set server_info [get_server_info $category $nick1 $nick2 $nick3]
        set user     [lindex $server_info 0]
        set host     [lindex $server_info 1]
        set pass_key [lindex $server_info 2]

        if {$pass_key eq "" } {
            puts "no match found for \[$category\] \[$nick1\] \[$nick2\] \[$nick3\] in $FILE_HOSTS"
        } else {
            set pass [get_pass_val $pass_key]
            if {$pass eq "" } {
                puts "no key found for \[${pass_key}\] in ${FILE_PASS}"
            } else {
                ssh $user $host $pass
            }
        }
    }
}

# ------------------------------------------------------------------------------
main


